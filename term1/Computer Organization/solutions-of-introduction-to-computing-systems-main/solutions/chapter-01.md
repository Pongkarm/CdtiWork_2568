# Chapter 01

1. First idea: we can do every same thing with every computer if we have enough time and memory.
	1. Second idea: abstraction makes computer work. With abstraction, we can make PC things to do we want, in spite of we are using natural human language but computer use electrons for making things.
---
2. No, maybe it can make easier instructing from a human perspective, but there is no such difference for computer in that way.
---
3. Increasing precision in analog machines can be very hard. But in contrary for a digital machine might need just more memory.
---
4. Some words and phrases can create ambiguity because of literally and figuratively meanings.
---
5. Solution:
	1. BoxAdd(BoxMult(a,x), b)
	2. BoxAdd(BoxAdd(w,x),BoxAdd(y,z))/4
	3. BoxMult(BoxAdd(a+b))
---
6. There is man, there is man. There is a man like a man. (This is a translated joke from my native language from Turkish. If you're not familiar, it can be very meaningless.)
	1. First, indicates there are two men and they look like a man.
	2. Second, indicates there are some men not carry masculinity of a man, but others are carrying this masculinity.
---
7. In this example, you will be at the mercy of a taxi driver. If everything is perfect, you won't need to say anything besides telling that. But in contrary, taxi driver might you take a nice(!) city tour in city. (Best case)
---
8.  At least 2. Even without figurative meanings, natural language sentences might carry lots of ambiguity.
	1. He might see a man holding a telescope with hand in park.
	2. He might see a man in the park with using his telescope.
---
9. Carrying that much ambiguity makes them incapable of expressing algorithms.
---
10. Solution:
	1. Definiteness means every step is precisely stated.
	2. Effective computability means each step can be doable for a computer.
	3. Finiteness means algorithm steps ends.
---
11. Solution:
	1. "Go to when you feel enough.‚Äù This is lacks of definiteness because enough isn't stated.
	2. "Multiply zero then divide with that number." This lacks effective computability because you can't any number to zero.
	3. "Sum Fibonacci sequence until you reach negative." This lacks finiteness because this is impossible to reach.
---
12. Solution:
	1. It is an algorithm.
	2. This lacks finiteness because we can't match every possible number.
	3. It is an algorithm.
	4. It is an algorithm.
	5. This lacks finiteness because it ignores odd numbers. With odd number you might not reach 0.
---
13. Both of them solve the same amount of problem. B just need more steps for reproducing subtract operation with negative sum of the given value.
---
14. Solution:
	1. 4 algorithms x 5 languages x 2 ISA x 3 micro architecture = 120
	2. Merge sort, C, x86 ISA, Intel Celeron. Quick sort, pascal, sparc, pentium 3. Bubble sort, C++, x86, Amd Athlon64
	3. Same amount.
---
15. Higher level languages tend to have more abstraction and those abstractions make us more productive, but if we don't know what is the underlying knowledge of abstraction when we require, we can't take advantage of it.
---
16. Operations, data types and addressing modes.
---
17. ISA is the abstraction of microarchitectures. Microarchitecture is about physical design of computer and ISA's are first abstraction interface to making run things on it without dealing with the hardware.
---
18. Generally just one ISA for microarchitecture, but many microarchitecture for just one ISA.
---
19. Solution:
	1. Problem: Sorting unsorted number array.
	2. Algorithm: Merge sort
	3. Language: C
	4. ISA: x86
	5. Microarchitecture: Amd Athlon64
	6. Circuits:
	7. Devices:
---
20. Yes, because it is abstract something about layer itself and gives necessary amount of control in top of it. Like microarchitecture design is about physical side of the computer but every microarchitecture with using same ISA stores data types in a certain way.
---
21. It is compiled program, this means it is ISA form. It can be read by the machine's microarchitecture itself. Because you don't nothing run it for mostly.
---
22. ISA to microarchitecture. Because it converts form marginally, from electron to physical material.
---
23. Because abstraction makes bridges between generation. This is the one of the main reasons of ISA's existence.
